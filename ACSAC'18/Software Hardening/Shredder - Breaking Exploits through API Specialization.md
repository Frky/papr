# Shredder: Breaking Exploits through API Specialization
*by Shachee Mishra - 05/12/18*

## Defenging against vulnerability exploitation

Exploitable bugs in popular software still exist; finding/fixing vulns is not enough; exploit mitigation technologies aim to make vuln exploitation harder

Target exploits: 
* shellcode (injected malicious code),
* code reuse (ret-to-libc, etc).

## Attack surface reduction

**Code debloating**: remove unused parts of code. 

### Exploits
* use code not be used by application => *attack breaks*
* use code used by application => *attack succeeds*

### Granularity
* function level (code stripping),
* functionnality level (finer)

## Typical ROP exploiitation workflow

* step 1: exploit vunl./bug to gain control of PC
* step 2: Prepare ROP payload
* step 3: execute ROP payload + shellcod

Shredder: attempts to mitigate the last two steps. 

API Specialization:
asumption: attack has hijacked control flow

Goal: breaak the exploit code by restricting its inteaction with the OS

Key insight: not all available API functions are used by most apps

Fro example, kernel32.dll exports 1941 functions! Not all of them are used by a given application (ofc). 

## Code stripping

**Idea:** remove non-imported functions from process address space
**Result:** attackers can no longer access/exploit them

Problem: LoadLibrary, GetProcAddress, CreateProcess, VirtualProtect and VirtualAlloc are imported by a lot
of applications! GetProcAddress is a huge issue, because from this it is possible to import any other function. 

## Shredder

Create specialized versions of critical API functions for individual applications
* critical == 52 security-critical API functions
* e.g., VirtualProtect, etc.

**Goal:** neutralize dangerous argument values or combinations

Main intuition: ...

### Design

* Shredder transparently protexts application binaries (does not require source code)
* Best-effort approach (may not always break exploits, may be easy to bypass)

### Sample exploit code
```
BOOL WINAPI VirtualProtect(
    lpAddress, 
    dwSize, 
    flNewProtect, // special values for exploitation => can be forbidden
    lpflOldProtect
);
```

### Approach

* phase 1: offline pre-processing
    * disassembly binary
    * extract CFG
    * identify criutical function call sites
    * extract argument values and patterns
    * generate process-wide per-function policies
* pase 2: runtime reinformcement

### Example

If in the legitimate application, VirtualProtect is always called with the same hard-coded values as third parameters, then 
only these ones are allowed at run-time. 

### What does a policy look like?

```
if (unction == VirtualProtect) {
    if ((flag == 0x20 AND dwSize == 0x1000) or (flag == ...)) {
        /* Call VirtualProtect */
    } else {
        /* ATTACK !! */
    }
}
```

## Evaluation

251 shellcodes and 30 ROP payload samples

Applications: 10 most popular end-user programs (web browsers, media players, etc.

Main results (compared to Code Stripping): 
    * breaks 18.3% more shellcode samples
    * **breaks 298% more ROP payload samples**

### Known arguments

Experimetns to see how often do we know arguments of critical functions: seems to be quite often for at least
one value of a critical function (more than 70%). 

### Breaking shellcode

...

## Summary

* Shredder is a best effort attack surface reduction tool
* Relies on static analysis
* Policies restrict the application usage of critical API functions
* Experiments: evaluation across 10 popular user applications
* Main result: breaks 298% of ROP attacks
